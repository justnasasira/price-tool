<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory & Pricing Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #2563eb;
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-secondary {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .btn-secondary:hover {
            background: #f3f4f6;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-white {
            background: rgba(255,255,255,0.9);
            color: #2563eb;
        }

        .btn-white:hover {
            background: white;
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .toolbar-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .toolbar-row + .toolbar-row {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .exchange-rate-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .exchange-rate-group label {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .exchange-rate-group input {
            width: 100px;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        /* Search and Filters */
        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .filter-select {
            padding: 10px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            user-select: none;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Bulk Actions */
        .bulk-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .selection-info {
            font-size: 0.875rem;
            color: #6b7280;
        }

        /* Product Cards */
        .products-grid {
            display: grid;
            gap: 16px;
        }

        .product-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: box-shadow 0.2s;
        }

        .product-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .product-card.selected {
            border: 2px solid #3b82f6;
        }

        .product-card.out-of-stock {
            opacity: 0.7;
        }

        .product-card.inactive {
            background: #f9fafb;
            border-left: 4px solid #9ca3af;
        }

        .product-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .product-checkbox {
            margin-top: 4px;
        }

        .product-info {
            flex: 1;
        }

        .product-name {
            font-weight: 600;
            font-size: 1rem;
            color: #111827;
            margin-bottom: 4px;
        }

        .product-meta {
            font-size: 0.8rem;
            color: #6b7280;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .product-meta span {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .stock-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stock-badge.in-stock {
            background: #d1fae5;
            color: #065f46;
        }

        .stock-badge.out-of-stock {
            background: #fee2e2;
            color: #991b1b;
        }

        .stock-badge:hover {
            transform: scale(1.05);
        }

        .product-prices {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 12px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .price-item {
            text-align: center;
        }

        .price-label {
            font-size: 0.7rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .price-value {
            font-weight: 600;
            color: #111827;
        }

        .price-value.usd {
            color: #059669;
        }

        .price-value.ugx {
            color: #2563eb;
        }

        .product-specs {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .specs-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .specs-label {
            font-size: 0.8rem;
            color: #6b7280;
            min-width: 70px;
        }

        .specs-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .specs-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .specs-row-full {
            flex-direction: column;
            align-items: flex-start;
        }

        .specs-row-full .specs-label {
            margin-bottom: 6px;
        }

        .specs-textarea {
            width: 100%;
            min-height: 120px;
            padding: 10px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
            line-height: 1.6;
        }

        .specs-textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 0.75rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
        }

        .modal-close:hover {
            color: #111827;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 6px;
            color: #374151;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        .form-group textarea {
            min-height: 200px;
            font-family: monospace;
            resize: vertical;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Update Diff */
        .diff-section {
            margin-bottom: 24px;
        }

        .diff-section h3 {
            font-size: 1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .diff-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .diff-badge.exact { background: #d1fae5; color: #065f46; }
        .diff-badge.likely { background: #fef3c7; color: #92400e; }
        .diff-badge.new { background: #dbeafe; color: #1e40af; }
        .diff-badge.missing { background: #fee2e2; color: #991b1b; }

        .diff-item {
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .diff-item.exact { border-left: 4px solid #10b981; }
        .diff-item.likely { border-left: 4px solid #f59e0b; }
        .diff-item.new { border-left: 4px solid #3b82f6; }
        .diff-item.missing { border-left: 4px solid #ef4444; }

        .diff-item-checkbox {
            flex-shrink: 0;
        }

        .diff-item-content {
            flex: 1;
        }

        .diff-item-name {
            font-weight: 500;
        }

        .diff-item-details {
            font-size: 0.85rem;
            color: #6b7280;
        }

        .diff-item-price-change {
            font-size: 0.85rem;
        }

        .price-up { color: #dc2626; }
        .price-down { color: #059669; }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 16px;
        }

        .empty-state h3 {
            font-size: 1.25rem;
            margin-bottom: 8px;
            color: #374151;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
        }

        .toast {
            background: #1f2937;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 8px;
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast.success { background: #059669; }
        .toast.error { background: #dc2626; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pagination */
        .pagination-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            gap: 12px;
        }

        .pagination-container:empty {
            display: none;
        }

        .pagination-info {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pagination-btn {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .pagination-select {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
        }

        .page-numbers {
            display: flex;
            gap: 4px;
        }

        .page-number {
            min-width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .page-number:hover {
            background: #f3f4f6;
        }

        .page-number.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .page-number.ellipsis {
            border: none;
            cursor: default;
        }

        .page-number.ellipsis:hover {
            background: transparent;
        }

        /* Responsive */
        @media (max-width: 992px) {
            .product-prices {
                grid-template-columns: repeat(3, 1fr);
            }

            .bulk-actions {
                width: 100%;
                justify-content: flex-start;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }

            .header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
                padding: 12px 16px;
                border-radius: 8px;
            }

            .header h1 {
                font-size: 1.25rem;
            }

            .header-buttons {
                width: 100%;
                justify-content: center;
            }

            .toolbar {
                padding: 12px;
            }

            .toolbar-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .exchange-rate-group {
                margin-left: 0;
                justify-content: space-between;
                width: 100%;
            }

            .exchange-rate-group input {
                flex: 1;
            }

            .search-input {
                width: 100%;
            }

            .filter-select {
                width: 100%;
            }

            .bulk-actions {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .bulk-actions .checkbox-label {
                justify-content: space-between;
            }

            .bulk-actions .btn {
                width: 100%;
                justify-content: center;
            }

            .product-card {
                padding: 12px;
            }

            .product-header {
                flex-wrap: wrap;
            }

            .product-name {
                font-size: 0.95rem;
            }

            .product-meta {
                font-size: 0.75rem;
            }

            .stock-badge {
                margin-top: 8px;
                width: 100%;
                text-align: center;
            }

            .product-prices {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                padding: 10px;
            }

            .price-item {
                padding: 4px;
            }

            .price-label {
                font-size: 0.65rem;
            }

            .price-value {
                font-size: 0.85rem;
            }

            .specs-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .specs-row .btn-sm {
                width: 100%;
            }

            .specs-label {
                min-width: auto;
            }

            /* Pagination mobile */
            .pagination-container {
                flex-direction: column;
                gap: 10px;
            }

            .pagination-controls {
                width: 100%;
                justify-content: space-between;
            }

            .page-numbers {
                display: none;
            }

            .pagination-info {
                text-align: center;
                width: 100%;
            }

            /* Modal mobile */
            .modal {
                max-height: 100vh;
                height: 100%;
                border-radius: 0;
                max-width: 100%;
            }

            .modal-overlay {
                padding: 0;
            }

            .modal-header {
                padding: 16px;
            }

            .modal-body {
                padding: 16px;
            }

            .modal-footer {
                padding: 12px 16px;
                flex-direction: column;
                gap: 8px;
            }

            .modal-footer .btn {
                width: 100%;
            }

            .form-group textarea {
                min-height: 150px;
            }

            /* Settings mobile */
            .settings-section {
                padding-bottom: 16px;
                margin-bottom: 16px;
            }

            .settings-section > div {
                flex-direction: column;
            }

            .settings-section .btn {
                width: 100%;
            }

            /* Diff items mobile */
            .diff-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .diff-item-checkbox {
                align-self: flex-start;
            }
        }

        @media (max-width: 480px) {
            .product-prices {
                grid-template-columns: 1fr 1fr;
            }

            .header-buttons {
                flex-direction: column;
                width: 100%;
            }

            .header-buttons .btn {
                width: 100%;
            }

            .btn {
                padding: 10px 14px;
                font-size: 0.9rem;
            }

            .exchange-rate-group {
                flex-wrap: wrap;
            }

            .exchange-rate-group label {
                width: 100%;
                margin-bottom: 4px;
            }
        }

        /* Confidence indicator */
        .confidence-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: #fef3c7;
            color: #92400e;
        }

        /* Settings sections */
        .settings-section {
            margin-bottom: 24px;
            padding-bottom: 24px;
            border-bottom: 1px solid #e5e7eb;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h3 {
            font-size: 1rem;
            margin-bottom: 16px;
            color: #374151;
        }

        /* Month tag badge */
        .month-tag {
            display: inline-block;
            padding: 2px 8px;
            background: #e0e7ff;
            color: #3730a3;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        /* Cloud sync status */
        .cloud-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 0.875rem;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-indicator.disconnected {
            background: #9ca3af;
        }

        .status-indicator.connected {
            background: #10b981;
        }

        .status-indicator.syncing {
            background: #3b82f6;
            animation: pulse 1s infinite;
        }

        .status-indicator.error {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-sync-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            font-size: 0.75rem;
            color: white;
        }

        .header-sync-status .status-indicator {
            width: 8px;
            height: 8px;
        }

        /* AI Format Section */
        .ai-format-section {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
        }

        .ai-format-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #0369a1;
        }

        .ai-badge {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ai-format-options {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        /* Format Preview */
        .format-preview {
            margin-top: 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            overflow: hidden;
        }

        .format-preview.hidden {
            display: none;
        }

        .format-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #f3f4f6;
            border-bottom: 1px solid #d1d5db;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .format-preview pre {
            margin: 0;
            padding: 14px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8rem;
            background: #f9fafb;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Spinner in button */
        .btn .spinner {
            width: 14px;
            height: 14px;
            border-width: 2px;
            margin-left: 6px;
        }

        .btn .spinner.hidden {
            display: none;
        }

        /* Processing overlay */
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 16px;
        }

        .processing-overlay.hidden {
            display: none;
        }

        .processing-text {
            margin-top: 16px;
            color: #6b7280;
            font-size: 0.9rem;
        }

        .processing-step {
            margin-top: 8px;
            color: #9ca3af;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>Inventory & Pricing Tool</h1>
            <div class="header-buttons">
                <div class="header-sync-status" id="headerSyncStatus" onclick="openSettingsModal()" style="cursor: pointer;" title="Click to configure cloud sync">
                    <span class="status-indicator disconnected" id="headerSyncIndicator"></span>
                    <span id="headerSyncText">Offline</span>
                </div>
                <button class="btn btn-white" onclick="openImportModal()">Import Price List</button>
                <button class="btn btn-white" onclick="openSettingsModal()">Settings</button>
            </div>
        </header>

        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-row">
                <input type="text" class="search-input" id="searchInput" placeholder="Search products..." oninput="filterProducts()">
                <select class="filter-select" id="categoryFilter" onchange="filterProducts()">
                    <option value="">All Categories</option>
                </select>
                <label class="checkbox-label">
                    <input type="checkbox" id="inStockFilter" onchange="filterProducts()">
                    In Stock Only
                </label>
                <div class="exchange-rate-group">
                    <label>Exchange Rate:</label>
                    <input type="number" id="exchangeRateInput" value="3750" onchange="updateExchangeRate()">
                    <span>UGX/USD</span>
                </div>
            </div>
            <div class="toolbar-row">
                <div class="bulk-actions">
                    <label class="checkbox-label">
                        <input type="checkbox" id="selectAll" onchange="toggleSelectAll()">
                        Select All
                    </label>
                    <span class="selection-info" id="selectionInfo">0 selected</span>
                    <select class="filter-select" id="priceTypeSelect">
                        <option value="vat">VAT Price (18%)</option>
                        <option value="markup">Markup Price (30%)</option>
                        <option value="base">Base Price</option>
                    </select>
                    <select class="filter-select" id="currencySelect">
                        <option value="ugx">UGX</option>
                        <option value="usd">USD</option>
                    </select>
                    <button class="btn btn-success" onclick="copySelectedToClipboard()">Copy Selected</button>
                    <button class="btn btn-primary" onclick="bulkEnrichSEO()" id="bulkEnrichBtn">Enrich SEO</button>
                    <button class="btn btn-danger" onclick="bulkDeleteProducts()">Delete Selected</button>
                </div>
            </div>
        </div>

        <!-- Pagination Controls Top -->
        <div class="pagination-container" id="paginationTop">
            <!-- Populated dynamically -->
        </div>

        <!-- Products Grid -->
        <div class="products-grid" id="productsGrid">
            <div class="empty-state">
                <div class="empty-state-icon">ðŸ“¦</div>
                <h3>No Products Yet</h3>
                <p>Import a price list to get started</p>
                <button class="btn btn-primary" style="margin-top: 16px;" onclick="openImportModal()">Import Price List</button>
            </div>
        </div>

        <!-- Pagination Controls Bottom -->
        <div class="pagination-container" id="paginationBottom">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal-overlay hidden" id="importModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Import Price List</h2>
                <button class="modal-close" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Paste your price list below:</label>
                    <textarea id="importTextarea" placeholder="Paste any format - messy text, tables, spreadsheet data, etc.

Example formats supported:
- Raw text lists
- CSV/Tab-separated data
- Copied from Excel/Sheets
- WhatsApp messages
- Email content"></textarea>
                </div>
                <div class="ai-format-section" id="aiFormatSection">
                    <div class="ai-format-header">
                        <span class="ai-badge">AI</span>
                        <span>Data Formatting</span>
                    </div>
                    <p style="font-size: 0.85rem; color: #6b7280; margin-bottom: 12px;">
                        Use AI to clean and structure messy data before parsing. Recommended for non-standard formats.
                    </p>
                    <div class="ai-format-options">
                        <label class="checkbox-label">
                            <input type="checkbox" id="useAiFormat" checked>
                            Auto-format with AI (requires API key)
                        </label>
                    </div>
                </div>
                <div class="format-preview hidden" id="formatPreview">
                    <div class="format-preview-header">
                        <span>Formatted Preview</span>
                        <button class="btn btn-secondary btn-sm" onclick="editFormattedData()">Edit</button>
                    </div>
                    <pre id="formattedDataPreview"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">Cancel</button>
                <button class="btn btn-primary" id="importActionBtn" onclick="handleImport()">
                    <span id="importBtnText">Format & Parse</span>
                    <span id="importBtnSpinner" class="spinner hidden"></span>
                </button>
            </div>
        </div>
    </div>

    <!-- Update Preview Modal -->
    <div class="modal-overlay hidden" id="updateModal">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Review Import Changes</h2>
                <button class="modal-close" onclick="closeUpdateModal()">&times;</button>
            </div>
            <div class="modal-body" id="updateModalBody">
                <!-- Populated dynamically -->
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeUpdateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyImportChanges()">Apply Selected Changes</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay hidden" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h3>Pricing Configuration</h3>
                    <div class="form-group">
                        <label>Exchange Rate (UGX per USD)</label>
                        <input type="number" id="settingsExchangeRate" value="3750">
                    </div>
                    <div class="form-group">
                        <label>VAT Rate (%)</label>
                        <input type="number" id="settingsVatRate" value="18" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Markup Rate (%)</label>
                        <input type="number" id="settingsMarkupRate" value="30" step="0.1">
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Gemini API (for AI Features)</h3>
                    <div class="form-group">
                        <label>API Key</label>
                        <input type="password" id="settingsGeminiKey" placeholder="Enter your Gemini API key">
                    </div>
                    <div class="form-group">
                        <label>Model</label>
                        <select class="filter-select" id="settingsGeminiModel" style="width: 100%;">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash (Recommended)</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro (Most Capable)</option>
                            <option value="gemini-2.0-flash">Gemini 2.0 Flash (Legacy)</option>
                        </select>
                    </div>
                    <p style="font-size: 0.85rem; color: #6b7280;">
                        Get your API key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>
                    </p>
                </div>
                <div class="settings-section">
                    <h3>Cloud Sync (Supabase)</h3>
                    <div class="cloud-status" id="cloudStatusSettings">
                        <span class="status-indicator disconnected"></span>
                        <span id="cloudStatusText">Not connected</span>
                    </div>
                    <div class="form-group">
                        <label>Supabase Project URL</label>
                        <input type="text" id="settingsSupabaseUrl" placeholder="https://your-project.supabase.co">
                    </div>
                    <div class="form-group">
                        <label>Supabase Anon Key</label>
                        <input type="password" id="settingsSupabaseKey" placeholder="your-anon-key">
                    </div>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px;">
                        <button class="btn btn-primary" onclick="testSupabaseConnection()">Test Connection</button>
                        <button class="btn btn-success" onclick="syncToCloud()">Sync to Cloud</button>
                        <button class="btn btn-secondary" onclick="loadFromCloud()">Load from Cloud</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #6b7280; margin-top: 12px;">
                        Create tables in Supabase SQL Editor:<br>
                        <code style="font-size: 0.75rem; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">products</code> (id, data, user_id, updated_at) and
                        <code style="font-size: 0.75rem; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">settings</code> (id, data, user_id, updated_at)
                    </p>
                </div>
                <div class="settings-section">
                    <h3>Local Data Management</h3>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="exportData()">Export Data (JSON)</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('importFileInput').click()">Import Data (JSON)</button>
                        <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importDataFile(event)">
                        <button class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSettingsModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- AI Matching Modal -->
    <div class="modal-overlay hidden" id="aiMatchModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2>AI Product Matching</h2>
                <button class="modal-close" onclick="closeAiMatchModal()">&times;</button>
            </div>
            <div class="modal-body" id="aiMatchModalBody">
                <div style="text-align: center; padding: 40px;">
                    <div class="spinner" style="width: 40px; height: 40px; border-width: 4px;"></div>
                    <p style="margin-top: 16px; color: #6b7280;">Analyzing products with Gemini AI...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // =====================
        // Data Store
        // =====================
        let products = [];
        let settings = {
            exchangeRate: 3750,
            geminiApiKey: '',
            geminiModel: 'gemini-2.5-flash',
            vatRate: 0.18,
            markupRate: 0.30,
            itemsPerPage: 10,
            supabaseUrl: 'https://tflweplhibgehesebdjk.supabase.co',
            supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRmbHdlcGxoaWJnZWhlc2ViZGprIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAzOTk3MTgsImV4cCI6MjA4NTk3NTcxOH0.qY93vmQ_yrKg1Nk8DBFR82x34XKTHP11WNkuh5nDSF8'
        };

        const AVAILABLE_MODELS = [
            { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (Recommended)' },
            { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro (Most Capable)' },
            { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash (Legacy)' }
        ];
        let selectedProducts = new Set();
        let pendingImport = null;
        let currentPage = 1;
        let supabaseClient = null;
        let syncStatus = 'disconnected'; // 'disconnected', 'connected', 'syncing', 'error'

        // =====================
        // Initialization
        // =====================
        function init() {
            loadFromStorage();

            // Initialize Supabase (non-blocking)
            try {
                initSupabase();
            } catch (error) {
                console.error('Supabase init error:', error);
                updateSyncStatus('disconnected');
            }

            renderProducts();
            updateCategoryFilter();

            const exchangeInput = document.getElementById('exchangeRateInput');
            if (exchangeInput) {
                exchangeInput.value = settings.exchangeRate;
            }
        }

        function loadFromStorage() {
            try {
                const savedProducts = localStorage.getItem('priceTool_products');
                const savedSettings = localStorage.getItem('priceTool_settings');

                if (savedProducts) {
                    products = JSON.parse(savedProducts);
                }
                if (savedSettings) {
                    settings = { ...settings, ...JSON.parse(savedSettings) };
                }
            } catch (error) {
                console.error('Error loading from storage:', error);
            }
        }

        function saveToStorage() {
            try {
                localStorage.setItem('priceTool_products', JSON.stringify(products));
                localStorage.setItem('priceTool_settings', JSON.stringify(settings));
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }

            // Auto-sync to cloud if connected
            if (supabaseClient && syncStatus === 'connected') {
                debouncedCloudSync();
            }
        }

        // Debounce cloud sync to avoid too many requests
        let syncTimeout = null;
        function debouncedCloudSync() {
            if (syncTimeout) clearTimeout(syncTimeout);
            syncTimeout = setTimeout(() => {
                syncToCloud(true); // silent sync
            }, 2000);
        }

        // =====================
        // Supabase Integration
        // =====================
        function initSupabase() {
            // Check if Supabase library is loaded
            if (typeof window.supabase === 'undefined') {
                console.warn('Supabase library not loaded. Cloud sync unavailable.');
                updateSyncStatus('disconnected');
                return;
            }

            if (settings.supabaseUrl && settings.supabaseKey) {
                try {
                    supabaseClient = window.supabase.createClient(settings.supabaseUrl, settings.supabaseKey);
                    testSupabaseConnection(true); // silent test
                } catch (error) {
                    console.error('Failed to initialize Supabase:', error);
                    updateSyncStatus('error');
                }
            } else {
                updateSyncStatus('disconnected');
            }
        }

        function updateSyncStatus(status, message) {
            syncStatus = status;

            const headerIndicator = document.getElementById('headerSyncIndicator');
            const headerText = document.getElementById('headerSyncText');
            const settingsIndicator = document.querySelector('#cloudStatusSettings .status-indicator');
            const settingsText = document.getElementById('cloudStatusText');

            const statusConfig = {
                disconnected: { class: 'disconnected', text: 'Offline', headerText: 'Offline' },
                connected: { class: 'connected', text: 'Connected to cloud', headerText: 'Cloud' },
                syncing: { class: 'syncing', text: 'Syncing...', headerText: 'Syncing...' },
                error: { class: 'error', text: message || 'Connection error', headerText: 'Error' }
            };

            const config = statusConfig[status] || statusConfig.disconnected;

            if (headerIndicator) {
                headerIndicator.className = 'status-indicator ' + config.class;
            }
            if (headerText) {
                headerText.textContent = config.headerText;
            }
            if (settingsIndicator) {
                settingsIndicator.className = 'status-indicator ' + config.class;
            }
            if (settingsText) {
                settingsText.textContent = config.text;
            }
        }

        async function testSupabaseConnection(silent = false) {
            // Check if Supabase library is loaded
            if (typeof window.supabase === 'undefined') {
                if (!silent) showToast('Supabase library not loaded. Try refreshing the page.', 'error');
                updateSyncStatus('disconnected');
                return false;
            }

            const url = document.getElementById('settingsSupabaseUrl')?.value || settings.supabaseUrl;
            const key = document.getElementById('settingsSupabaseKey')?.value || settings.supabaseKey;

            if (!url || !key) {
                if (!silent) showToast('Please enter Supabase URL and Key', 'error');
                updateSyncStatus('disconnected');
                return false;
            }

            try {
                updateSyncStatus('syncing');

                // Create or update client
                supabaseClient = window.supabase.createClient(url, key);

                // Test connection by querying the products table
                const { data, error } = await supabaseClient.from('products').select('id').limit(1);

                if (error) {
                    throw error;
                }

                updateSyncStatus('connected');
                if (!silent) showToast('Connected to Supabase successfully!', 'success');
                return true;
            } catch (error) {
                console.error('Supabase connection error:', error);
                updateSyncStatus('error', error.message);
                if (!silent) showToast('Connection failed: ' + error.message, 'error');
                return false;
            }
        }

        async function syncToCloud(silent = false) {
            if (!supabaseClient || typeof window.supabase === 'undefined') {
                if (!silent) showToast('Cloud sync not available. Check your connection.', 'error');
                return;
            }

            try {
                updateSyncStatus('syncing');

                // Get user ID (use a device ID for simplicity, or implement auth)
                const userId = getDeviceId();

                // Sync products
                const { error: productsError } = await supabaseClient
                    .from('products')
                    .upsert({
                        id: userId,
                        data: products,
                        user_id: userId,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (productsError) throw productsError;

                // Sync settings (without sensitive keys for security)
                const settingsToSync = { ...settings };
                delete settingsToSync.supabaseKey; // Don't sync the key itself
                delete settingsToSync.geminiApiKey; // Don't sync API keys

                const { error: settingsError } = await supabaseClient
                    .from('settings')
                    .upsert({
                        id: userId,
                        data: settingsToSync,
                        user_id: userId,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (settingsError) throw settingsError;

                updateSyncStatus('connected');
                if (!silent) showToast(`Synced ${products.length} products to cloud`, 'success');
            } catch (error) {
                console.error('Sync error:', error);
                updateSyncStatus('error', error.message);
                if (!silent) showToast('Sync failed: ' + error.message, 'error');
            }
        }

        async function loadFromCloud() {
            if (!supabaseClient || typeof window.supabase === 'undefined') {
                showToast('Cloud sync not available. Check your connection.', 'error');
                return;
            }

            try {
                updateSyncStatus('syncing');

                const userId = getDeviceId();

                // Load products
                const { data: productsData, error: productsError } = await supabaseClient
                    .from('products')
                    .select('data')
                    .eq('id', userId)
                    .single();

                if (productsError && productsError.code !== 'PGRST116') {
                    throw productsError;
                }

                // Load settings
                const { data: settingsData, error: settingsError } = await supabaseClient
                    .from('settings')
                    .select('data')
                    .eq('id', userId)
                    .single();

                if (settingsError && settingsError.code !== 'PGRST116') {
                    throw settingsError;
                }

                // Apply loaded data
                if (productsData?.data) {
                    products = productsData.data;
                }

                if (settingsData?.data) {
                    // Merge settings but keep local API keys
                    const localKeys = {
                        supabaseUrl: settings.supabaseUrl,
                        supabaseKey: settings.supabaseKey,
                        geminiApiKey: settings.geminiApiKey
                    };
                    settings = { ...settings, ...settingsData.data, ...localKeys };
                }

                // Save to local storage
                localStorage.setItem('priceTool_products', JSON.stringify(products));
                localStorage.setItem('priceTool_settings', JSON.stringify(settings));

                // Update UI
                document.getElementById('exchangeRateInput').value = settings.exchangeRate;
                updateCategoryFilter();
                renderProducts();

                updateSyncStatus('connected');
                showToast(`Loaded ${products.length} products from cloud`, 'success');
            } catch (error) {
                console.error('Load from cloud error:', error);
                updateSyncStatus('error', error.message);
                showToast('Failed to load: ' + error.message, 'error');
            }
        }

        function getDeviceId() {
            let deviceId = localStorage.getItem('priceTool_deviceId');
            if (!deviceId) {
                deviceId = 'device_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('priceTool_deviceId', deviceId);
            }
            return deviceId;
        }

        // =====================
        // Price Calculations
        // =====================
        function calculatePrices(basePrice) {
            const vatPrice = basePrice * (1 + settings.vatRate);
            const markupPrice = basePrice * (1 + settings.markupRate);

            return {
                base: {
                    usd: basePrice,
                    ugx: basePrice * settings.exchangeRate
                },
                vat: {
                    usd: vatPrice,
                    ugx: vatPrice * settings.exchangeRate
                },
                markup: {
                    usd: markupPrice,
                    ugx: markupPrice * settings.exchangeRate
                }
            };
        }

        function formatCurrency(amount, currency = 'ugx') {
            if (currency === 'usd') {
                return '$' + amount.toFixed(2);
            }
            return 'UGX ' + Math.round(amount).toLocaleString();
        }

        // =====================
        // Price List Parser
        // =====================
        function parsePriceList(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const products = [];
            let currentCategory = '';
            let currentMonthTag = '';
            let currentProduct = null;

            // Patterns
            const monthPattern = /^(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{4}$/i;
            const categoryPattern = /^[A-Z][A-Z\s&]+$/;
            const pricePattern = /^@\s*(\d+(?:\.\d+)?)\s*(\+)?$/;
            const productLinePattern = /^(?:\d+\s+)?(.+)$/;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // Check for month tag
                if (monthPattern.test(line)) {
                    currentMonthTag = line.toUpperCase();
                    continue;
                }

                // Check for category header (all caps, no numbers)
                if (categoryPattern.test(line) && !pricePattern.test(line)) {
                    currentCategory = line;
                    continue;
                }

                // Check for price line
                const priceMatch = line.match(pricePattern);
                if (priceMatch && currentProduct) {
                    currentProduct.basePrice = parseFloat(priceMatch[1]);
                    currentProduct.vatIncluded = !priceMatch[2]; // + means VAT not included
                    products.push(currentProduct);
                    currentProduct = null;
                    continue;
                }

                // Check for product line (may start with number)
                const productMatch = line.match(productLinePattern);
                if (productMatch && !pricePattern.test(line)) {
                    // If we have a pending product without price, skip it
                    if (currentProduct) {
                        // Check if this line might be a price
                        continue;
                    }

                    let productName = productMatch[1].trim();

                    // Remove leading number if present
                    productName = productName.replace(/^\d+\s+/, '');

                    // Extract SKU if present (starts with #)
                    let sku = '';
                    const skuMatch = productName.match(/#([A-Z0-9-]+)/i);
                    if (skuMatch) {
                        sku = skuMatch[1];
                        productName = productName.replace(/#[A-Z0-9-]+/i, '').trim();
                    }

                    currentProduct = {
                        id: generateId(),
                        name: productName,
                        sku: sku,
                        category: currentCategory,
                        basePrice: 0,
                        vatIncluded: false,
                        monthTag: currentMonthTag,
                        inStock: true,
                        active: true,
                        seoTitle: '',
                        specs: '',
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                }
            }

            return products;
        }

        function generateId() {
            return 'p_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // =====================
        // Product Rendering
        // =====================
        function renderProducts() {
            const grid = document.getElementById('productsGrid');
            const filteredProducts = getFilteredProducts();
            const totalItems = filteredProducts.length;
            const itemsPerPage = settings.itemsPerPage || 10;
            const totalPages = Math.ceil(totalItems / itemsPerPage);

            // Reset to page 1 if current page is out of bounds
            if (currentPage > totalPages) {
                currentPage = Math.max(1, totalPages);
            }

            // Clear pagination if no products
            if (filteredProducts.length === 0) {
                document.getElementById('paginationTop').innerHTML = '';
                document.getElementById('paginationBottom').innerHTML = '';

                if (products.length === 0) {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ“¦</div>
                            <h3>No Products Yet</h3>
                            <p>Import a price list to get started</p>
                            <button class="btn btn-primary" style="margin-top: 16px;" onclick="openImportModal()">Import Price List</button>
                        </div>
                    `;
                } else {
                    grid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ðŸ”</div>
                            <h3>No Matching Products</h3>
                            <p>Try adjusting your search or filters</p>
                        </div>
                    `;
                }
                return;
            }

            // Get current page items
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageProducts = filteredProducts.slice(startIndex, endIndex);

            grid.innerHTML = pageProducts.map(product => renderProductCard(product)).join('');
            updateSelectionInfo();

            // Render pagination
            renderPagination(totalItems, totalPages, 'paginationTop');
            renderPagination(totalItems, totalPages, 'paginationBottom');
        }

        function renderPagination(totalItems, totalPages, containerId) {
            const container = document.getElementById(containerId);
            const itemsPerPage = settings.itemsPerPage || 10;
            const startItem = (currentPage - 1) * itemsPerPage + 1;
            const endItem = Math.min(currentPage * itemsPerPage, totalItems);

            if (totalPages <= 1) {
                container.innerHTML = `
                    <div class="pagination-info">
                        Showing ${totalItems} product${totalItems !== 1 ? 's' : ''}
                    </div>
                `;
                return;
            }

            // Generate page numbers
            let pageNumbers = '';
            const maxVisiblePages = 5;

            if (totalPages <= maxVisiblePages) {
                for (let i = 1; i <= totalPages; i++) {
                    pageNumbers += `<button class="page-number ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i}</button>`;
                }
            } else {
                // Always show first page
                pageNumbers += `<button class="page-number ${1 === currentPage ? 'active' : ''}" onclick="goToPage(1)">1</button>`;

                if (currentPage > 3) {
                    pageNumbers += `<span class="page-number ellipsis">...</span>`;
                }

                // Show pages around current
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);

                for (let i = start; i <= end; i++) {
                    pageNumbers += `<button class="page-number ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i}</button>`;
                }

                if (currentPage < totalPages - 2) {
                    pageNumbers += `<span class="page-number ellipsis">...</span>`;
                }

                // Always show last page
                pageNumbers += `<button class="page-number ${totalPages === currentPage ? 'active' : ''}" onclick="goToPage(${totalPages})">${totalPages}</button>`;
            }

            container.innerHTML = `
                <div class="pagination-info">
                    Showing ${startItem}-${endItem} of ${totalItems} products
                </div>
                <div class="pagination-controls">
                    <button class="pagination-btn" onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
                        â† Prev
                    </button>
                    <div class="page-numbers">
                        ${pageNumbers}
                    </div>
                    <button class="pagination-btn" onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
                        Next â†’
                    </button>
                    <select class="pagination-select" onchange="changeItemsPerPage(this.value)">
                        <option value="5" ${itemsPerPage === 5 ? 'selected' : ''}>5 / page</option>
                        <option value="10" ${itemsPerPage === 10 ? 'selected' : ''}>10 / page</option>
                        <option value="20" ${itemsPerPage === 20 ? 'selected' : ''}>20 / page</option>
                        <option value="50" ${itemsPerPage === 50 ? 'selected' : ''}>50 / page</option>
                        <option value="100" ${itemsPerPage === 100 ? 'selected' : ''}>100 / page</option>
                    </select>
                </div>
            `;
        }

        function goToPage(page) {
            const filteredProducts = getFilteredProducts();
            const totalPages = Math.ceil(filteredProducts.length / (settings.itemsPerPage || 10));

            if (page < 1 || page > totalPages) return;

            currentPage = page;
            renderProducts();

            // Scroll to top of products
            document.getElementById('productsGrid').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function changeItemsPerPage(value) {
            settings.itemsPerPage = parseInt(value) || 10;
            currentPage = 1;
            saveToStorage();
            renderProducts();
        }

        function renderProductCard(product) {
            const prices = calculatePrices(product.basePrice);
            const isSelected = selectedProducts.has(product.id);
            const stockClass = product.inStock ? 'in-stock' : 'out-of-stock';
            const cardClass = `product-card ${isSelected ? 'selected' : ''} ${!product.inStock ? 'out-of-stock' : ''} ${!product.active ? 'inactive' : ''}`;

            return `
                <div class="${cardClass}" data-id="${product.id}">
                    <div class="product-header">
                        <input type="checkbox" class="product-checkbox"
                            ${isSelected ? 'checked' : ''}
                            ${!product.inStock ? 'disabled' : ''}
                            onchange="toggleProductSelection('${product.id}')">
                        <div class="product-info">
                            <div class="product-name">${escapeHtml(product.name)}</div>
                            <div class="product-meta">
                                <span>ðŸ“ ${escapeHtml(product.category || 'Uncategorized')}</span>
                                ${product.sku ? `<span>ðŸ·ï¸ ${escapeHtml(product.sku)}</span>` : ''}
                                ${product.monthTag ? `<span class="month-tag">${escapeHtml(product.monthTag)}</span>` : ''}
                                ${!product.active ? '<span style="color: #9ca3af;">âš ï¸ Inactive</span>' : ''}
                            </div>
                        </div>
                        <span class="stock-badge ${stockClass}" onclick="toggleStock('${product.id}')">
                            ${product.inStock ? 'âœ“ In Stock' : 'âœ— Out of Stock'}
                        </span>
                    </div>
                    <div class="product-prices">
                        <div class="price-item">
                            <div class="price-label">Base (USD)</div>
                            <div class="price-value usd">${formatCurrency(prices.base.usd, 'usd')}</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">VAT ${Math.round(settings.vatRate * 100)}%</div>
                            <div class="price-value usd">${formatCurrency(prices.vat.usd, 'usd')}</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">Markup ${Math.round(settings.markupRate * 100)}%</div>
                            <div class="price-value usd">${formatCurrency(prices.markup.usd, 'usd')}</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">Base (UGX)</div>
                            <div class="price-value ugx">${formatCurrency(prices.base.ugx, 'ugx')}</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">VAT (UGX)</div>
                            <div class="price-value ugx">${formatCurrency(prices.vat.ugx, 'ugx')}</div>
                        </div>
                        <div class="price-item">
                            <div class="price-label">Markup (UGX)</div>
                            <div class="price-value ugx">${formatCurrency(prices.markup.ugx, 'ugx')}</div>
                        </div>
                    </div>
                    <div class="product-specs">
                        <div class="specs-row">
                            <span class="specs-label">SEO Title:</span>
                            <input type="text" class="specs-input" value="${escapeHtml(product.seoTitle)}"
                                onchange="updateProductField('${product.id}', 'seoTitle', this.value)"
                                placeholder="Click 'Get Specs' or enter manually">
                            <button class="btn btn-secondary btn-sm" onclick="getSpecs('${product.id}')">Get Specs</button>
                        </div>
                        <div class="specs-row specs-row-full">
                            <span class="specs-label">Specs:</span>
                            <textarea class="specs-textarea"
                                onchange="updateProductField('${product.id}', 'specs', this.value)"
                                placeholder="Product specifications">${escapeHtml(product.specs)}</textarea>
                        </div>
                    </div>
                </div>
            `;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // =====================
        // Filtering
        // =====================
        function getFilteredProducts() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const categoryFilter = document.getElementById('categoryFilter').value;
            const inStockOnly = document.getElementById('inStockFilter').checked;

            return products.filter(p => {
                if (!p.active && !searchTerm) return false; // Hide inactive unless searching
                if (inStockOnly && !p.inStock) return false;
                if (categoryFilter && p.category !== categoryFilter) return false;
                if (searchTerm) {
                    const searchFields = [p.name, p.sku, p.category, p.seoTitle].filter(Boolean).join(' ').toLowerCase();
                    if (!searchFields.includes(searchTerm)) return false;
                }
                return true;
            });
        }

        function filterProducts() {
            selectedProducts.clear();
            document.getElementById('selectAll').checked = false;
            currentPage = 1; // Reset to first page when filtering
            renderProducts();
        }

        function updateCategoryFilter() {
            const categories = [...new Set(products.map(p => p.category).filter(Boolean))].sort();
            const select = document.getElementById('categoryFilter');
            select.innerHTML = '<option value="">All Categories</option>' +
                categories.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
        }

        // =====================
        // Selection & Bulk Actions
        // =====================
        function toggleProductSelection(id) {
            if (selectedProducts.has(id)) {
                selectedProducts.delete(id);
            } else {
                selectedProducts.add(id);
            }
            updateSelectionInfo();
            renderProducts();
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll').checked;
            const filtered = getFilteredProducts().filter(p => p.inStock);

            if (selectAll) {
                filtered.forEach(p => selectedProducts.add(p.id));
            } else {
                selectedProducts.clear();
            }

            renderProducts();
        }

        function updateSelectionInfo() {
            document.getElementById('selectionInfo').textContent = `${selectedProducts.size} selected`;
        }

        function copySelectedToClipboard() {
            if (selectedProducts.size === 0) {
                showToast('Please select products first', 'error');
                return;
            }

            const priceType = document.getElementById('priceTypeSelect').value;
            const currency = document.getElementById('currencySelect').value;

            const selectedList = products.filter(p => selectedProducts.has(p.id) && p.inStock);

            const priceLabels = {
                base: 'Base price',
                vat: `VAT inclusive (${Math.round(settings.vatRate * 100)}%)`,
                markup: `${Math.round(settings.markupRate * 100)}% markup`
            };

            const lines = selectedList.map(p => {
                const prices = calculatePrices(p.basePrice);
                const price = prices[priceType][currency];
                const displayName = p.seoTitle || p.name;
                return `${displayName} â€“ ${formatCurrency(price, currency)} (${priceLabels[priceType]})`;
            });

            const text = lines.join('\n');

            navigator.clipboard.writeText(text).then(() => {
                showToast(`Copied ${selectedList.length} items to clipboard`, 'success');
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast(`Copied ${selectedList.length} items to clipboard`, 'success');
            });
        }

        // =====================
        // Bulk Operations
        // =====================
        function bulkDeleteProducts() {
            if (selectedProducts.size === 0) {
                showToast('Please select products to delete', 'error');
                return;
            }

            const count = selectedProducts.size;
            if (!confirm(`Are you sure you want to delete ${count} product(s)? This cannot be undone.`)) {
                return;
            }

            // Remove selected products from array
            products = products.filter(p => !selectedProducts.has(p.id));
            selectedProducts.clear();

            saveToStorage();
            updateCategoryFilter();
            renderProducts();
            document.getElementById('selectAll').checked = false;
            showToast(`Deleted ${count} product(s)`, 'success');
        }

        let bulkEnrichInProgress = false;

        async function bulkEnrichSEO() {
            if (selectedProducts.size === 0) {
                showToast('Please select products to enrich', 'error');
                return;
            }

            if (!settings.geminiApiKey) {
                showToast('Please set your Gemini API key in Settings', 'error');
                return;
            }

            if (bulkEnrichInProgress) {
                showToast('Bulk enrichment already in progress', 'error');
                return;
            }

            const selectedList = products.filter(p => selectedProducts.has(p.id));
            const total = selectedList.length;

            if (!confirm(`This will generate SEO-friendly titles with real specs for ${total} product(s). Continue?`)) {
                return;
            }

            bulkEnrichInProgress = true;
            const btn = document.getElementById('bulkEnrichBtn');
            const originalText = btn.textContent;
            btn.disabled = true;

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < selectedList.length; i++) {
                const product = selectedList[i];
                btn.innerHTML = `Enriching ${i + 1}/${total}... <span class="spinner"></span>`;

                try {
                    const result = await enrichProductWithAI(product.name);
                    if (result) {
                        product.seoTitle = result.seoTitle || product.seoTitle;
                        product.specs = result.specs || product.specs;
                        product.updatedAt = Date.now();
                        successCount++;
                    }

                    // Small delay between requests to avoid rate limiting
                    if (i < selectedList.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } catch (error) {
                    console.error(`Error enriching ${product.name}:`, error);
                    errorCount++;
                }
            }

            saveToStorage();
            renderProducts();

            bulkEnrichInProgress = false;
            btn.disabled = false;
            btn.textContent = originalText;

            if (errorCount > 0) {
                showToast(`Enriched ${successCount} products, ${errorCount} failed`, 'success');
            } else {
                showToast(`Successfully enriched ${successCount} product(s)`, 'success');
            }
        }

        // =====================
        // Stock Management
        // =====================
        function toggleStock(id) {
            const product = products.find(p => p.id === id);
            if (product) {
                product.inStock = !product.inStock;
                product.updatedAt = Date.now();
                if (!product.inStock) {
                    selectedProducts.delete(id);
                }
                saveToStorage();
                renderProducts();
            }
        }

        // =====================
        // Product Updates
        // =====================
        function updateProductField(id, field, value) {
            const product = products.find(p => p.id === id);
            if (product) {
                product[field] = value;
                product.updatedAt = Date.now();
                saveToStorage();
            }
        }

        function updateExchangeRate() {
            settings.exchangeRate = parseFloat(document.getElementById('exchangeRateInput').value) || 3750;
            saveToStorage();
            renderProducts();
        }

        // =====================
        // Gemini API Integration
        // =====================
        async function getSpecs(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            if (!settings.geminiApiKey) {
                showToast('Please set your Gemini API key in Settings', 'error');
                return;
            }

            // Show loading state
            const card = document.querySelector(`[data-id="${productId}"]`);
            const btn = card.querySelector('.btn-sm');
            const originalText = btn.textContent;
            btn.innerHTML = '<span class="spinner"></span>';
            btn.disabled = true;

            try {
                const result = await enrichProductWithAI(product.name);
                if (result) {
                    product.seoTitle = result.seoTitle || '';
                    product.specs = result.specs || '';
                    product.updatedAt = Date.now();
                    saveToStorage();
                    renderProducts();

                    if (!result.confident) {
                        showToast('SEO title generated but may be uncertain - please verify', 'success');
                    } else {
                        showToast('SEO title enriched successfully', 'success');
                    }
                }
            } catch (error) {
                console.error('Gemini API error:', error);
                showToast('Failed to enrich. Check your API key.', 'error');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function enrichProductWithAI(productName) {
            const model = settings.geminiModel || 'gemini-2.5-flash';
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${settings.geminiApiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: `You are a product data specialist. Given a product name, create an SEO-friendly title and detailed technical specifications.

Product: "${productName}"

TASK 1 - SEO Title:
Create a formatted product title like this:
"Brand Model: Key Specs Summary"

Example: "Dell Vostro 3030 MT: Intel Core i5 12th Gen, 8GB RAM, 512GB SSD, 19.5" E2020H Monitor, Ubuntu"

TASK 2 - Technical Specifications:
Create detailed specs using âœ… bullet points. Include ALL relevant specifications:

Example format:
âœ… Processor: Intel Core i5 12th Gen (up to 4.4GHz, Intel Smart Cache, multi-core performance)
âœ… Graphics: Integrated Intel UHD Graphics 730
âœ… Memory: 8GB DDR4-3200 RAM (expandable up to 64GB, dual DIMM slots)
âœ… Storage: 512GB PCIe NVMe SSD
âœ… Display: Dell 19.5" E2020H Monitor (1600x900, Anti-glare, 60Hz, VGA + DisplayPort)
âœ… Operating System: Ubuntu Linux
âœ… Connectivity: Gigabit Ethernet, HDMI, VGA, USB ports (USB-A 3.2 & 2.0)
âœ… Keyboard & Mouse: Dell Wired Keyboard + Wired Optical Mouse
âœ… Chassis: Mini Tower (MT), compact design
âœ… Power Supply: 180W (efficient PSU)
âœ… Warranty: 1 Year Manufacturer's Warranty
âœ… Color: Black

For MONITORS include: Panel type, Resolution, Refresh rate, Response time, Ports, Stand adjustments, VESA mount
For LAPTOPS include: Processor, RAM, Storage, Display, Graphics, Battery, Weight, Ports, OS, Warranty
For DESKTOPS include: Processor, RAM, Storage, Graphics, Ports, Bundled monitor specs, OS, Warranty

Look up the ACTUAL specifications for this product from your knowledge.

Respond in JSON format:
{
  "seoTitle": "Brand Model: Key Specs Summary",
  "specs": "âœ… Spec1: Details\\nâœ… Spec2: Details\\nâœ… Spec3: Details...",
  "confident": true/false
}

IMPORTANT: In the specs field, use \\n for line breaks between each âœ… item.
Set confident to false if you're unsure about the exact model specifications.`
                        }]
                    }],
                    generationConfig: {
                        temperature: 0.2,
                        maxOutputTokens: 2000
                    }
                })
            });

            if (!response.ok) {
                throw new Error('API request failed');
            }

            const data = await response.json();
            if (!data.candidates || data.candidates.length === 0) {
                throw new Error('No response from AI');
            }

            const text = data.candidates[0].content.parts.map(p => p.text || '').join('');
            const jsonMatch = text.match(/\{[\s\S]*\}/);

            if (jsonMatch) {
                const result = JSON.parse(jsonMatch[0]);
                // Convert escaped newlines to actual newlines
                if (result.specs) {
                    result.specs = result.specs.replace(/\\n/g, '\n');
                }
                return result;
            }
            return null;
        }

        // =====================
        // Import Functions
        // =====================
        let formattedData = null;
        let isFormatted = false;

        function openImportModal() {
            document.getElementById('importModal').classList.remove('hidden');
            document.getElementById('importTextarea').value = '';
            document.getElementById('formatPreview').classList.add('hidden');
            document.getElementById('useAiFormat').checked = !!settings.geminiApiKey;
            updateImportButton();
            formattedData = null;
            isFormatted = false;
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.add('hidden');
            formattedData = null;
            isFormatted = false;
        }

        function updateImportButton() {
            const useAi = document.getElementById('useAiFormat').checked;
            const btnText = document.getElementById('importBtnText');
            if (isFormatted) {
                btnText.textContent = 'Parse & Import';
            } else if (useAi && settings.geminiApiKey) {
                btnText.textContent = 'Format & Parse';
            } else {
                btnText.textContent = 'Parse & Preview';
            }
        }

        async function handleImport() {
            const rawText = document.getElementById('importTextarea').value.trim();
            if (!rawText) {
                showToast('Please paste a price list', 'error');
                return;
            }

            const useAiFormat = document.getElementById('useAiFormat').checked;
            const btn = document.getElementById('importActionBtn');
            const btnText = document.getElementById('importBtnText');
            const btnSpinner = document.getElementById('importBtnSpinner');

            // If already formatted, proceed to parse
            if (isFormatted && formattedData) {
                parseAndImport(formattedData);
                return;
            }

            // If AI formatting is enabled and we have an API key
            if (useAiFormat && settings.geminiApiKey) {
                btn.disabled = true;
                btnText.textContent = 'Formatting...';
                btnSpinner.classList.remove('hidden');

                try {
                    const formatted = await formatWithAI(rawText);
                    if (formatted) {
                        formattedData = formatted;
                        isFormatted = true;
                        showFormattedPreview(formatted);
                        btnText.textContent = 'Parse & Import';
                        showToast('Data formatted successfully. Review and click to import.', 'success');
                    } else {
                        // Fallback to direct parsing
                        showToast('AI formatting returned empty, using raw data', 'error');
                        parseAndImport(rawText);
                    }
                } catch (error) {
                    console.error('AI formatting error:', error);
                    showToast('AI formatting failed, parsing raw data', 'error');
                    parseAndImport(rawText);
                } finally {
                    btn.disabled = false;
                    btnSpinner.classList.add('hidden');
                }
            } else {
                // Direct parsing without AI formatting
                parseAndImport(rawText);
            }
        }

        async function formatWithAI(rawText) {
            const model = settings.geminiModel || 'gemini-2.5-flash';
            console.log('Using model:', model);
            console.log('Input length:', rawText.length);

            const requestBody = {
                contents: [{
                    parts: [{
                        text: `Convert this price list to a clean format. Include ALL items.

FORMAT:
- First line: month/year (e.g., FEB 2026)
- Category headers in ALL CAPS on own line
- Product name on one line (combine multi-line descriptions, include SKU codes)
- Price on next line as @NUMBER+
- Remove asterisks, line numbers, bullets

Example output:
FEB 2026
DESKTOPS

HP PRO TOWER 290 G9 CI3 14100 8GB 512GB 21.5" #C6QM6AT
@460+

Dell Optiplex 7020 Ci5 14th gen 8GB 512GB 20" E2020H
@580+

DATA TO FORMAT:
${rawText}

Output ONLY the formatted list. Include ALL products.`
                    }]
                }],
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 65536
                }
            };

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${settings.geminiApiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error:', errorText);
                throw new Error('API request failed: ' + errorText);
            }

            const data = await response.json();
            console.log('Full API response:', JSON.stringify(data, null, 2));

            // Check for different response structures
            if (!data.candidates || data.candidates.length === 0) {
                console.error('No candidates in response:', data);
                throw new Error('No response from AI');
            }

            const candidate = data.candidates[0];

            // Check finish reason
            if (candidate.finishReason) {
                console.log('Finish reason:', candidate.finishReason);
            }

            // Get text from response
            let text = '';
            if (candidate.content && candidate.content.parts) {
                text = candidate.content.parts.map(p => p.text || '').join('');
            }

            console.log('Response text length:', text.length);
            console.log('Response preview:', text.substring(0, 500));

            // Clean up the response - remove any markdown code blocks if present
            let cleaned = text
                .replace(/```[\w]*\n?/g, '')
                .replace(/```/g, '')
                .trim();

            return cleaned;
        }

        function showFormattedPreview(formatted) {
            const preview = document.getElementById('formatPreview');
            const previewContent = document.getElementById('formattedDataPreview');
            previewContent.textContent = formatted;
            preview.classList.remove('hidden');
        }

        function editFormattedData() {
            if (formattedData) {
                document.getElementById('importTextarea').value = formattedData;
                document.getElementById('formatPreview').classList.add('hidden');
                formattedData = null;
                isFormatted = false;
                updateImportButton();
                showToast('Formatted data copied to editor for manual editing', 'success');
            }
        }

        function parseAndImport(text) {
            if (!text) {
                text = document.getElementById('importTextarea').value.trim();
            }

            if (!text) {
                showToast('Please paste a price list', 'error');
                return;
            }

            const newProducts = parsePriceList(text);
            if (newProducts.length === 0) {
                showToast('No products found in the text. Try disabling AI formatting or adjusting the data.', 'error');
                return;
            }

            closeImportModal();

            if (products.length === 0) {
                // First import - just add everything
                products = newProducts;
                saveToStorage();
                updateCategoryFilter();
                renderProducts();
                showToast(`Imported ${newProducts.length} products`, 'success');
            } else {
                // Existing products - show diff
                if (settings.geminiApiKey) {
                    performAIMatching(newProducts);
                } else {
                    performSimpleMatching(newProducts);
                }
            }
        }

        // Simple matching (no AI)
        function performSimpleMatching(newProducts) {
            const matches = {
                exact: [],
                likely: [],
                new: [],
                missing: []
            };

            const existingByName = new Map();
            products.filter(p => p.active).forEach(p => {
                existingByName.set(normalizeProductName(p.name), p);
            });

            const matchedExisting = new Set();

            newProducts.forEach(np => {
                const normalized = normalizeProductName(np.name);
                const existing = existingByName.get(normalized);

                if (existing) {
                    matchedExisting.add(existing.id);
                    if (existing.basePrice === np.basePrice) {
                        matches.exact.push({ existing, new: np });
                    } else {
                        matches.likely.push({ existing, new: np, confidence: 1.0 });
                    }
                } else {
                    // Try fuzzy match
                    let bestMatch = null;
                    let bestScore = 0;

                    for (const [name, ep] of existingByName) {
                        if (matchedExisting.has(ep.id)) continue;
                        const score = similarityScore(normalized, name);
                        if (score > 0.7 && score > bestScore) {
                            bestScore = score;
                            bestMatch = ep;
                        }
                    }

                    if (bestMatch) {
                        matchedExisting.add(bestMatch.id);
                        matches.likely.push({ existing: bestMatch, new: np, confidence: bestScore });
                    } else {
                        matches.new.push(np);
                    }
                }
            });

            // Find missing products
            products.filter(p => p.active && !matchedExisting.has(p.id)).forEach(p => {
                matches.missing.push(p);
            });

            pendingImport = { matches, newProducts };
            showUpdateModal(matches);
        }

        // AI-powered matching
        async function performAIMatching(newProducts) {
            document.getElementById('aiMatchModal').classList.remove('hidden');

            try {
                const existingProducts = products.filter(p => p.active).map(p => ({
                    id: p.id,
                    name: p.name,
                    category: p.category,
                    basePrice: p.basePrice
                }));

                const newProductsList = newProducts.map(p => ({
                    name: p.name,
                    category: p.category,
                    basePrice: p.basePrice
                }));

                const model = settings.geminiModel || 'gemini-2.5-flash';
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${settings.geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Compare these product lists and identify matches. Account for:
- Name variations (abbreviations, typos, different formatting)
- Model number differences
- Same product, different price

EXISTING PRODUCTS:
${JSON.stringify(existingProducts, null, 2)}

NEW PRODUCTS:
${JSON.stringify(newProductsList, null, 2)}

Respond with JSON:
{
  "matches": [
    { "existingId": "id", "newIndex": 0, "confidence": 0.95, "reason": "Same product, price updated" }
  ],
  "newProducts": [0, 2, 5],  // indices of truly new products
  "missingIds": ["id1", "id2"]  // IDs of products not in new list
}`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 2000
                        }
                    })
                });

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                const jsonMatch = text.match(/\{[\s\S]*\}/);

                if (jsonMatch) {
                    const aiResult = JSON.parse(jsonMatch[0]);

                    const matches = {
                        exact: [],
                        likely: [],
                        new: [],
                        missing: []
                    };

                    // Process AI matches
                    aiResult.matches.forEach(m => {
                        const existing = products.find(p => p.id === m.existingId);
                        const np = newProducts[m.newIndex];
                        if (existing && np) {
                            if (m.confidence >= 0.95 && existing.basePrice === np.basePrice) {
                                matches.exact.push({ existing, new: np });
                            } else {
                                matches.likely.push({ existing, new: np, confidence: m.confidence, reason: m.reason });
                            }
                        }
                    });

                    // New products
                    (aiResult.newProducts || []).forEach(idx => {
                        if (newProducts[idx]) {
                            matches.new.push(newProducts[idx]);
                        }
                    });

                    // Missing products
                    (aiResult.missingIds || []).forEach(id => {
                        const p = products.find(pr => pr.id === id);
                        if (p) matches.missing.push(p);
                    });

                    pendingImport = { matches, newProducts };
                    closeAiMatchModal();
                    showUpdateModal(matches);
                }
            } catch (error) {
                console.error('AI matching error:', error);
                closeAiMatchModal();
                showToast('AI matching failed, using simple matching', 'error');
                performSimpleMatching(newProducts);
            }
        }

        function normalizeProductName(name) {
            return name.toLowerCase()
                .replace(/[^\w\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function similarityScore(str1, str2) {
            const words1 = str1.split(' ');
            const words2 = str2.split(' ');
            const allWords = new Set([...words1, ...words2]);
            const set1 = new Set(words1);
            const set2 = new Set(words2);

            let intersection = 0;
            allWords.forEach(w => {
                if (set1.has(w) && set2.has(w)) intersection++;
            });

            return intersection / allWords.size;
        }

        // =====================
        // Update Modal
        // =====================
        function showUpdateModal(matches) {
            const body = document.getElementById('updateModalBody');
            let html = '';

            // Exact matches
            if (matches.exact.length > 0) {
                html += `
                    <div class="diff-section">
                        <h3><span class="diff-badge exact">âœ“</span> Exact Matches (${matches.exact.length})</h3>
                        ${matches.exact.map((m, i) => `
                            <div class="diff-item exact">
                                <input type="checkbox" class="diff-item-checkbox" data-type="exact" data-index="${i}" checked>
                                <div class="diff-item-content">
                                    <div class="diff-item-name">${escapeHtml(m.existing.name)}</div>
                                    <div class="diff-item-details">Price: $${m.existing.basePrice} (no change)</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Likely matches (price changes)
            if (matches.likely.length > 0) {
                html += `
                    <div class="diff-section">
                        <h3><span class="diff-badge likely">~</span> Price Updates (${matches.likely.length})</h3>
                        ${matches.likely.map((m, i) => {
                            const priceDiff = m.new.basePrice - m.existing.basePrice;
                            const priceClass = priceDiff > 0 ? 'price-up' : 'price-down';
                            const priceSign = priceDiff > 0 ? '+' : '';
                            return `
                                <div class="diff-item likely">
                                    <input type="checkbox" class="diff-item-checkbox" data-type="likely" data-index="${i}" checked>
                                    <div class="diff-item-content">
                                        <div class="diff-item-name">${escapeHtml(m.existing.name)}</div>
                                        <div class="diff-item-details">
                                            ${m.reason ? `Match: ${m.reason}` : `Confidence: ${Math.round(m.confidence * 100)}%`}
                                        </div>
                                        <div class="diff-item-price-change ${priceClass}">
                                            $${m.existing.basePrice} â†’ $${m.new.basePrice} (${priceSign}$${priceDiff.toFixed(2)})
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // New products
            if (matches.new.length > 0) {
                html += `
                    <div class="diff-section">
                        <h3><span class="diff-badge new">+</span> New Products (${matches.new.length})</h3>
                        ${matches.new.map((p, i) => `
                            <div class="diff-item new">
                                <input type="checkbox" class="diff-item-checkbox" data-type="new" data-index="${i}" checked>
                                <div class="diff-item-content">
                                    <div class="diff-item-name">${escapeHtml(p.name)}</div>
                                    <div class="diff-item-details">Category: ${escapeHtml(p.category)} | Price: $${p.basePrice}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Missing products
            if (matches.missing.length > 0) {
                html += `
                    <div class="diff-section">
                        <h3><span class="diff-badge missing">-</span> No Longer Listed (${matches.missing.length})</h3>
                        ${matches.missing.map((p, i) => `
                            <div class="diff-item missing">
                                <input type="checkbox" class="diff-item-checkbox" data-type="missing" data-index="${i}" checked>
                                <div class="diff-item-content">
                                    <div class="diff-item-name">${escapeHtml(p.name)}</div>
                                    <div class="diff-item-details">Will be marked as inactive (not deleted)</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            if (!html) {
                html = '<p>No changes detected.</p>';
            }

            body.innerHTML = html;
            document.getElementById('updateModal').classList.remove('hidden');
        }

        function closeUpdateModal() {
            document.getElementById('updateModal').classList.add('hidden');
            pendingImport = null;
        }

        function closeAiMatchModal() {
            document.getElementById('aiMatchModal').classList.add('hidden');
        }

        function applyImportChanges() {
            if (!pendingImport) return;

            const { matches } = pendingImport;
            let updatedCount = 0;
            let addedCount = 0;
            let deactivatedCount = 0;

            // Process exact matches (keep as is, update month tag)
            document.querySelectorAll('[data-type="exact"]:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                const match = matches.exact[idx];
                if (match) {
                    match.existing.monthTag = match.new.monthTag;
                    match.existing.updatedAt = Date.now();
                }
            });

            // Process likely matches (update price)
            document.querySelectorAll('[data-type="likely"]:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                const match = matches.likely[idx];
                if (match) {
                    match.existing.basePrice = match.new.basePrice;
                    match.existing.monthTag = match.new.monthTag;
                    match.existing.updatedAt = Date.now();
                    updatedCount++;
                }
            });

            // Process new products
            document.querySelectorAll('[data-type="new"]:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                const newProduct = matches.new[idx];
                if (newProduct) {
                    products.push(newProduct);
                    addedCount++;
                }
            });

            // Process missing products (mark inactive)
            document.querySelectorAll('[data-type="missing"]:checked').forEach(cb => {
                const idx = parseInt(cb.dataset.index);
                const missingProduct = matches.missing[idx];
                if (missingProduct) {
                    missingProduct.active = false;
                    missingProduct.updatedAt = Date.now();
                    deactivatedCount++;
                }
            });

            saveToStorage();
            updateCategoryFilter();
            renderProducts();
            closeUpdateModal();

            const messages = [];
            if (updatedCount) messages.push(`${updatedCount} updated`);
            if (addedCount) messages.push(`${addedCount} added`);
            if (deactivatedCount) messages.push(`${deactivatedCount} deactivated`);

            showToast(messages.length ? messages.join(', ') : 'No changes applied', 'success');
        }

        // =====================
        // Settings
        // =====================
        function openSettingsModal() {
            document.getElementById('settingsExchangeRate').value = settings.exchangeRate;
            document.getElementById('settingsVatRate').value = settings.vatRate * 100;
            document.getElementById('settingsMarkupRate').value = settings.markupRate * 100;
            document.getElementById('settingsGeminiKey').value = settings.geminiApiKey || '';
            document.getElementById('settingsGeminiModel').value = settings.geminiModel || 'gemini-2.5-flash';
            document.getElementById('settingsSupabaseUrl').value = settings.supabaseUrl || '';
            document.getElementById('settingsSupabaseKey').value = settings.supabaseKey || '';
            document.getElementById('settingsModal').classList.remove('hidden');

            // Update sync status display
            updateSyncStatus(syncStatus);
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function saveSettings() {
            settings.exchangeRate = parseFloat(document.getElementById('settingsExchangeRate').value) || 3750;
            settings.vatRate = (parseFloat(document.getElementById('settingsVatRate').value) || 18) / 100;
            settings.markupRate = (parseFloat(document.getElementById('settingsMarkupRate').value) || 30) / 100;
            settings.geminiApiKey = document.getElementById('settingsGeminiKey').value.trim();
            settings.geminiModel = document.getElementById('settingsGeminiModel').value || 'gemini-2.5-flash';

            // Supabase settings
            const newSupabaseUrl = document.getElementById('settingsSupabaseUrl').value.trim();
            const newSupabaseKey = document.getElementById('settingsSupabaseKey').value.trim();

            // Reinitialize Supabase if credentials changed
            if (newSupabaseUrl !== settings.supabaseUrl || newSupabaseKey !== settings.supabaseKey) {
                settings.supabaseUrl = newSupabaseUrl;
                settings.supabaseKey = newSupabaseKey;
                initSupabase();
            }

            document.getElementById('exchangeRateInput').value = settings.exchangeRate;

            saveToStorage();
            renderProducts();
            closeSettingsModal();
            showToast('Settings saved', 'success');
        }

        // =====================
        // Data Export/Import
        // =====================
        function exportData() {
            const data = {
                products,
                settings,
                exportedAt: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `price-tool-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Data exported successfully', 'success');
        }

        function importDataFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.products && Array.isArray(data.products)) {
                        products = data.products;
                        if (data.settings) {
                            settings = { ...settings, ...data.settings };
                        }
                        saveToStorage();
                        updateCategoryFilter();
                        renderProducts();
                        document.getElementById('exchangeRateInput').value = settings.exchangeRate;
                        showToast(`Imported ${products.length} products`, 'success');
                    } else {
                        throw new Error('Invalid data format');
                    }
                } catch (error) {
                    showToast('Failed to import data: invalid format', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllData() {
            if (confirm('Are you sure you want to delete all products and reset settings? This cannot be undone.')) {
                products = [];
                // Preserve cloud settings
                const cloudSettings = {
                    supabaseUrl: settings.supabaseUrl,
                    supabaseKey: settings.supabaseKey
                };
                settings = {
                    exchangeRate: 3750,
                    geminiApiKey: '',
                    geminiModel: 'gemini-2.5-flash',
                    vatRate: 0.18,
                    markupRate: 0.30,
                    itemsPerPage: 10,
                    ...cloudSettings
                };
                currentPage = 1;
                selectedProducts.clear();
                saveToStorage();
                updateCategoryFilter();
                renderProducts();
                document.getElementById('exchangeRateInput').value = settings.exchangeRate;
                closeSettingsModal();
                showToast('All data cleared', 'success');
            }
        }

        // =====================
        // Toast Notifications
        // =====================
        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                ${type === 'success' ? 'âœ“' : 'âœ—'}
                <span>${escapeHtml(message)}</span>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // =====================
        // Initialize
        // =====================
        document.addEventListener('DOMContentLoaded', () => {
            try {
                init();
            } catch (error) {
                console.error('Initialization error:', error);
                // Try to at least render the UI
                try {
                    renderProducts();
                    updateCategoryFilter();
                } catch (e) {
                    console.error('UI render error:', e);
                }
            }

            // Set up AI format checkbox listener
            const aiFormatCheckbox = document.getElementById('useAiFormat');
            if (aiFormatCheckbox) {
                aiFormatCheckbox.addEventListener('change', updateImportButton);
            }
        });

        // Global error handler to prevent complete failure
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Global error:', msg, 'at line', lineNo);
            return false;
        };
    </script>
</body>
</html>
